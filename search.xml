<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F09%2F29%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[top]]></title>
    <url>%2F2018%2F09%2F28%2Ftop%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ThreadPoolExecutor]]></title>
    <url>%2F2018%2F09%2F28%2FThreadPoolExecutor%2F</url>
    <content type="text"><![CDATA[ThreadPoolExecutor​ 在多线程的编程环境下, 为了更好的控制线程的数量和状态, 提升性能和吞吐量, 通常会用到线程池, 接下来介绍JDK里的ThreadPoolExecutor线程池(下面简称为TPE). ​ 首先, TPE的继承关系为:flowa1=&gt;operation: Executora2=&gt;operation: ExecutorServicea3=&gt;operation: AbstractExecutorServicea4=&gt;operation: ThreadPoolExecutor12345678910111213141516171819202122232425262728293031323334//Worker和Task的区别，Worker是当前线程池中的线程，而task虽然是runnable，但是并没有真正执行，只是被Worker调用了run方法public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); /* * 如果当前的线程数小于核心线程池的大小，根据现有的线程作为第一个Worker运行的线程， * 新建一个Worker，addWorker自动的检查当前线程池的状态和Worker的数量， * 防止线程池在不能添加线程的状态下添加线程 * * 如果线程入队成功，然后还是要进行double-check的，因为线程池在入队之后状态是可能会发生变化的 * * 如果task不能入队(队列满了)，这时候尝试增加一个新线程，如果增加失败那么当前的线程池状态变化了或者线程池已经满了 * 然后拒绝task */ int c = ctl.get(); //当前的Worker的数量小于核心线程池大小时，新建一个Worker。 if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return; c = ctl.get(); &#125; if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) //recheck防止线程池状态的突变，如果突变，那么将reject线程，防止workQueue中增加新线程 reject(command); else if (workerCountOf(recheck) == 0) //上下两个操作都有addWorker的操作，但是如果在workQueue.offer的时候Worker变为0， //那么将没有Worker执行新的task，所以增加一个Worker. addWorker(null, false); &#125; //如果workQueue满了，那么这时候可能还没到线程池的maxnum，所以尝试增加一个Worker else if (!addWorker(command, false)) reject(command); //如果Worker数量到达上限，那么就拒绝此线程 &#125;]]></content>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[world]]></title>
    <url>%2F2018%2F09%2F28%2Fworld%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[hello]]></title>
    <url>%2F2018%2F09%2F28%2Fhello%2F</url>
    <content type="text"></content>
  </entry>
</search>
