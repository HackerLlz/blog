<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[top]]></title>
    <url>%2F2018%2F09%2F28%2Ftop%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ThreadPoolExecutor]]></title>
    <url>%2F2018%2F09%2F28%2FThreadPoolExecutor%2F</url>
    <content type="text"><![CDATA[ThreadPoolExecutor​ 在多线程的编程环境下, 为了更好的控制线程的数量和状态, 提升性能和吞吐量, 通常会用到线程池, 接下来介绍JDK里的ThreadPoolExecutor线程池(下面简称为TPE). ​ 首先, TPE的继承关系为: ​ Executor接口只有一个void execute(Runnable command) 方法, ExecutorService接口添加了许多重要的方法, 源码如下: 12345678910111213141516171819202122public interface ExecutorService extends Executor &#123; // 启动一个关闭命令，不再接受新任务 // 当所有工作队列的任务执行完后，就关闭 void shutdown(); // 与shutdown() 的区别是 直接清理工作队列的任务 // 并返回未执行的任务列表 List&lt;Runnable&gt; shutdownNow(); boolean isShutdown(); boolean isTerminated(); // 提交任务, 与execute() 的区别是 会返回任务处理结果 &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result); Future&lt;?&gt; submit(Runnable task); // 批量提交任务 &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException; &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException; &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException; &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; ​ TPE作为实现类, 构造出了一个可以将提交的任务用特定数量的工作线程按照流程来处理的线程池, 下面看一下TPE的构造方法, 了解其中都有哪些重要的参数. 123456789101112131415161718192021public ThreadPoolExecutor(int corePoolSize, //核心线程池大小 int maximumPoolSize, //最大线程池大小 long keepAliveTime, //工作线程空闲时间 TimeUnit unit, //空闲时间的单位 BlockingQueue&lt;Runnable&gt; workQueue, //工作队列 ThreadFactory threadFactory, //工作线程的创建工厂 RejectedExecutionHandler handler) &#123; //任务拒绝策略 if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; ​ 任务提交到线程池的时候, 先判断工作线程的数量是否到达核心 java//Worker和Task的区别，Worker是当前线程池中的线程，而task虽然是runnable，但是并没有真正执行，只是被Worker调用了run方法public void execute(Runnable command) { if (command == null) throw new NullPointerException(); /* * 如果当前的线程数小于核心线程池的大小，根据现有的线程作为第一个Worker运行的线程， * 新建一个Worker，addWorker自动的检查当前线程池的状态和Worker的数量， * 防止线程池在不能添加线程的状态下添加线程 * * 如果线程入队成功，然后还是要进行double-check的，因为线程池在入队之后状态是可能会发生变化的 * * 如果task不能入队(队列满了)，这时候尝试增加一个新线程，如果增加失败那么当前的线程池状态变化了或者线程池已经满了 * 然后拒绝task */ int c = ctl.get(); //当前的Worker的数量小于核心线程池大小时，新建一个Worker。 if (workerCountOf(c) &lt; corePoolSize) { if (addWorker(command, true)) return; c = ctl.get(); } if (isRunning(c) &amp;&amp; workQueue.offer(command)) { int recheck = ctl.get(); if (! isRunning(recheck) &amp;&amp; remove(command)) //recheck防止线程池状态的突变，如果突变，那么将reject线程，防止workQueue中增加新线程 reject(command); else if (workerCountOf(recheck) == 0) //上下两个操作都有addWorker的操作，但是如果在workQueue.offer的时候Worker变为0， //那么将没有Worker执行新的task，所以增加一个Worker. addWorker(null, false); } //如果workQueue满了，那么这时候可能还没到线程池的maxnum，所以尝试增加一个Worker else if (!addWorker(command, false)) reject(command); //如果Worker数量到达上限，那么就拒绝此线程 } a1=>operation: Executor a2=>operation: ExecutorService a3=>operation: AbstractExecutorService a4=>operation: ThreadPoolExecutor a1->a2->a3->a4{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[world]]></title>
    <url>%2F2018%2F09%2F28%2Fworld%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[hello]]></title>
    <url>%2F2018%2F09%2F28%2Fhello%2F</url>
    <content type="text"></content>
  </entry>
</search>
