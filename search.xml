<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ScheduledThreadPoolExecutor]]></title>
    <url>%2F2018%2F10%2F13%2FScheduledThreadPoolExecutor%2F</url>
    <content type="text"><![CDATA[schedule方法源码分析 温馨提示：看完我的另一篇ThreadPoolExecutor再来看这篇会轻松很多。 ThreadPoolExecutor中使用execute来提交任务，而ScheduledThreadPoolExecutor使用schedule。区别是，schedule会先把Task封装成ScheduledFutureTask再提交；schedule会直接把任务放入阻塞队列中等待延迟获取，而不是提交给新建的Worker。 12345678910111213public ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit) &#123; if (command == null || unit == null) throw new NullPointerException(); // decorateTask是留给用户自定义的方法; RunnableScheduledFuture&lt;?&gt; t = decorateTask(command, new ScheduledFutureTask&lt;Void&gt;(command, null, triggerTime(delay, unit))); // 封装成ScheduledFutureTask再提交任务 delayedExecute(t); return t;&#125; delayedExecute方法： 1234567891011121314151617181920private void delayedExecute(RunnableScheduledFuture&lt;?&gt; task) &#123; // 如果线程池已经关闭，使用拒绝策略拒绝任务 if (isShutdown()) reject(task); else &#123; // 添加到阻塞队列中 super.getQueue().add(task); // 若为SHUTDOWN状态，当前线程池运行状态下不可以执行任务，从阻塞队列中删除任务成功，则取消任务； // 对于第二点，可以通过setContinueExistingPeriodicTasksAfterShutdownPolicy方法设置在线程池关闭时，周期任务继续执行， // 默认为false，也就是线程池关闭时，不再执行周期任务。 if (isShutdown() &amp;&amp; !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp; remove(task)) task.cancel(false); else // 提交任务时就增加一个worker，确保线程池中至少有一个线程启动，即使corePoolSize为0 // 该方法在ThreadPoolExecutor中实现，里面调addWorker ensurePrestart(); &#125;&#125; ScheduledFutureTask 继承自FutureTask，构造方法里三个重要的属性：time，下次任务执行时的时间；period，执行周期；sequenceNumber，任务被添加到队里中的序号。 ScheduledFutureTask入队时会调用getDelay来获得延迟时间进行排序（take方法中出现） 1234public long getDelay(TimeUnit unit) &#123; // 执行时间减去当前系统时间 return unit.convert(time - now(), NANOSECONDS);&#125; 当任务被woker取出以后，会执行run方法，run方法如下： 123456789101112131415161718public void run() &#123; // 是否是周期性任务 boolean periodic = isPeriodic(); // 当前线程池运行状态下如果不可以执行任务，取消该任务 if (!canRunInCurrentRunState(periodic)) cancel(false); // 如果不是周期性任务，调用FutureTask中的run方法执行 else if (!periodic) ScheduledFutureTask.super.run(); // 如果是周期性任务，调用FutureTask中的runAndReset方法执行 // runAndReset方法不会返回执行结果，所以可以重复执行任务 else if (ScheduledFutureTask.super.runAndReset()) &#123; // 计算下次执行该任务的时间 setNextRunTime(); // 重复执行任务 reExecutePeriodic(outerTask); &#125;&#125; 给ScheduledFutureTask设置周期性任务有两个方法，scheduleAtFixedRate ：以固定的延迟时间执行任务（不受执行时间影响）；scheduleWithFixedDelay：执行完任务后再延迟固定时间执行任务。 DelayedWorkQueue DelayedWorkQueue是基于最小堆的优先级队列（PriorityQueue），任务出入队时会进行最小堆排序（siftUp和siftDown），将延迟时间最小的排在队头等待Worker获取执行。堆结构在执行插入和删除操作时的最坏时间复杂度是 O(logN)。 offer方法 任务入队时的方法： 123456789101112131415161718192021222324252627282930313233public boolean offer(Runnable x) &#123; if (x == null) throw new NullPointerException(); RunnableScheduledFuture&lt;?&gt; e = (RunnableScheduledFuture&lt;?&gt;)x; final ReentrantLock lock = this.lock; lock.lock(); try &#123; int i = size; // DelayedWorkQueue类似于数组，如果容量不够需要扩容 if (i &gt;= queue.length) grow(); size = i + 1; // 队列中没有数据时 if (i == 0) &#123; queue[0] = e; // 设置任务在队中的索引 setIndex(e, 0); &#125; else &#123; // 队列中有数据时，入队时的堆排序 siftUp(i, e); &#125; // 如果传入的任务是队列的第一个节点 if (queue[0] == e) &#123; // leader的作用在讲完take和poll方法后再讲 leader = null; // 发出信号唤醒worker available.signal(); &#125; &#125; finally &#123; lock.unlock(); &#125; return true;&#125; siftUp方法（本文的两个堆排看不懂的可以详见参考链接”简书”）： 从刚入队的key叶子节点开始，循环的根据key节点与它的父节点来判断，如果key节点的执行时间小于父节点，则将两个节点交换，最终使延迟最小任务的排在堆顶，即队头（兄弟节点之间不需要大小要求） 12345678910111213141516171819private void siftUp(int k, RunnableScheduledFuture&lt;?&gt; key) &#123; while (k &gt; 0) &#123; // 找到父节点的索引 int parent = (k - 1) &gt;&gt;&gt; 1; // 获取父节点 RunnableScheduledFuture&lt;?&gt; e = queue[parent]; // 如果key节点的执行时间大于父节点的延迟时间，不需要再排序了 if (key.compareTo(e) &gt;= 0) break; // 如果key.compareTo(e) &lt; 0，说明key节点的延迟时间小于父节点的延迟时间，需要把父节点移到后面 queue[k] = e; // 设置索引为k setIndex(e, k); k = parent; &#125; // key设置为排序后的位置 queue[k] = key; setIndex(key, k);&#125; take方法和poll方法 两者区别是，take会阻塞直到取得任务，poll可以设置超时时间不会一直阻塞（线程最大空闲时间使用）。 12345678910111213141516171819202122232425262728293031323334353637383940414243public RunnableScheduledFuture&lt;?&gt; take() throws InterruptedException &#123; final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; for (;;) &#123; // 取得队头元素 RunnableScheduledFuture&lt;?&gt; first = queue[0]; // 若队头为空，则等待任务offer队列时发信号唤醒 if (first == null) available.await(); else &#123; // 获得延迟时间（ScheduledFutureTask的getDelay方法） long delay = first.getDelay(NANOSECONDS); // 延迟时间到期 if (delay &lt;= 0) // 出队执行（里面有siftDown） return finishPoll(first); first = null; // leader != null 代表队头任务已经有一个线程在等待执行，其他线程只需等待唤醒 if (leader != null代表) available.await(); else &#123; // 否则把任务交给当前线程执行，即把leader设置为当前线程， Thread thisThread = Thread.currentThread(); leader = thisThread; try &#123; // 等待任务延迟时间后执行 available.awaitNanos(delay); &#125; finally &#123; // 设置leader = null，让其他线程执行下一个任务; if (leader == thisThread) leader = null; &#125; &#125; &#125; &#125; &#125; finally &#123; // 如果leader为空且队列不为空则唤醒其他线程执行下一个任务 if (leader == null &amp;&amp; queue[0] != null) available.signal(); lock.unlock(); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public RunnableScheduledFuture&lt;?&gt; poll(long timeout, TimeUnit unit) throws InterruptedException &#123; // poll超时时间（纳秒） long nanos = unit.toNanos(timeout); final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; for (;;) &#123; RunnableScheduledFuture&lt;?&gt; first = queue[0]; if (first == null) &#123; if (nanos &lt;= 0) return null; else nanos = available.awaitNanos(nanos); &#125; else &#123; long delay = first.getDelay(NANOSECONDS); // 延迟时间到期，出队执行 if (delay &lt;= 0) return finishPoll(first); // poll超时，返回null if (nanos &lt;= 0) return null; first = null; // nanos &lt; delay 说明需要等待的时间小于任务要执行的延迟时间 // leader != null 说明有其它线程正在对任务进行阻塞 if (nanos &lt; delay || leader != null) // 这时阻塞当前线程nanos纳秒（期间若有新任务加入且排在队头，才有机会取出任务执行） nanos = available.awaitNanos(nanos); else &#123; Thread thisThread = Thread.currentThread(); leader = thisThread; try &#123; // timeLeft表示delay减去实际的等待时间 long timeLeft = available.awaitNanos(delay); // 计算剩余的等待时间 nanos -= delay - timeLeft; &#125; finally &#123; if (leader == thisThread) leader = null; &#125; &#125; &#125; &#125; &#125; finally &#123; if (leader == null &amp;&amp; queue[0] != null) available.signal(); lock.unlock(); &#125;&#125; leader的存在是要减少不必要的时间等待。若没有leader，比如说现在队列中的第一个任务1分钟后执行，用户提交新的任务时会不断的增加woker线程，如果新提交的任务都排在队列后面（较晚执行），也就是说新的woker现在都会取出这第一个任务进行执行延迟时间的等待（上述的 available.awaitNanos(delay) 方法），当该任务到触发时间时，会唤醒很多woker线程，这显然是没有必要的。 finishPoll方法 take和poll的出队执行操作： 123456789101112private RunnableScheduledFuture&lt;?&gt; finishPoll(RunnableScheduledFuture&lt;?&gt; f) &#123; // 数组长度-1 int s = --size; // 取出最后一个节点 RunnableScheduledFuture&lt;?&gt; x = queue[s]; queue[s] = null; // 长度不为0，则从第一个元素开始排序，目的是要把最后一个节点放到合适的位置上 if (s != 0) siftDown(0, x); setIndex(f, -1); return f;&#125; siftDown方法： 12345678910111213141516171819202122232425private void siftDown(int k, RunnableScheduledFuture&lt;?&gt; key) &#123; // 根据二叉堆的特性，数组长度除以2，表示取有子节点的索引 int half = size &gt;&gt;&gt; 1; // 判断索引为k的节点是否有子节点 while (k &lt; half) &#123; // 左子节点的索引 int child = (k &lt;&lt; 1) + 1; RunnableScheduledFuture&lt;?&gt; c = queue[child]; // 右子节点的索引 int right = child + 1; // 如果有右子节点并且左子节点的延迟时间大于右子节点，取延迟时间最小的节点 if (right &lt; size &amp;&amp; c.compareTo(queue[right]) &gt; 0) c = queue[child = right]; // 如果key的延迟时间小于等于c的延迟时间，跳出循环 if (key.compareTo(c) &lt;= 0) break; // 设置要移除索引的节点为其子节点 queue[k] = c; setIndex(c, k); k = child; &#125; // 将key放入索引为k的位置 queue[k] = key; setIndex(key, k);&#125; 总结 ScheduledThreadPoolExecutor可以说是在ThreadPoolExecutor上面进行了一些扩展操作，它只是重新包装了任务以及阻塞队列，实现了延迟，周期性执行任务的功能。可用与订单支付限时，周期性订正等任务。 本博客用 rabbitmq 实现了简单的延迟队列的功能，感兴趣详见： 参考简书：深入理解Java线程池：ScheduledThreadPoolExecutor 思否：Java调度线程池ScheduledThreadPoolExecutor源码分析]]></content>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[top]]></title>
    <url>%2F2018%2F09%2F28%2Ftop%2F</url>
    <content type="text"><![CDATA[测试置顶!!!]]></content>
  </entry>
  <entry>
    <title><![CDATA[ThreadPoolExecutor]]></title>
    <url>%2F2018%2F09%2F28%2FThreadPoolExecutor%2F</url>
    <content type="text"><![CDATA[ThreadPoolExecutor的族谱 在多线程的编程环境下, 为了更好的控制线程的数量和状态, 提升性能和吞吐量, 通常会用到线程池, 接下来介绍JDK里的ThreadPoolExecutor线程池. 首先, ThreadPoolExecutor的继承关系为: Executor接口只有一个void execute(Runnable command) 方法, ExecutorService接口添加了许多重要的方法, 源码如下: 12345678910111213141516171819202122public interface ExecutorService extends Executor &#123; // 启动一个关闭命令，不再接受新任务 // 当所有工作队列的任务执行完后，就关闭 void shutdown(); // 与shutdown() 的区别是 直接清理工作队列的任务 // 并返回未执行的任务列表 List&lt;Runnable&gt; shutdownNow(); boolean isShutdown(); boolean isTerminated(); // 提交任务, 与execute() 的区别是 会返回任务处理结果 &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result); Future&lt;?&gt; submit(Runnable task); // 批量提交任务 &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException; &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException; &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException; &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; 提交任务过程中几个参数的作用 ThreadPoolExecutor作为实现类, 构造出了一个可以将提交的任务用特定数量的工作线程按照流程来处理的线程池, 下面看一下TPE的构造方法, 了解其中都有哪些重要的参数: 123456789101112131415161718192021public ThreadPoolExecutor(int corePoolSize, //核心线程池大小 int maximumPoolSize, //最大线程池大小 long keepAliveTime, //工作线程空闲时间 TimeUnit unit, //空闲时间的单位 BlockingQueue&lt;Runnable&gt; workQueue, //工作队列（阻塞队列） ThreadFactory threadFactory, //工作线程的创建工厂 RejectedExecutionHandler handler) &#123; //任务拒绝策略 if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; 现在讲述execute 方法的执行过程来理解各个参数的作用, 先来看一张图: 主线程execute 提交任务到线程池时, 线程池会先判断工作线程的数量是否小于核心线程池大小, 若是则添加一个工作线程直接执行该任务, 反之将任务加入到工作队列中. 当工作队列也满时, 线程池会继续增加工作线程来处理未能加入到工作队列中的任务, 直到工作线程的数量到达最大线程池大小, 对于继续提交的任务就会采取拒绝策略. 以上的论述中, 补充以下几点: keepAliveTime: 线程多久没有任务执行就会终止的时间间隔. 当工作线程执行完一个任务之后就会用getTask 方法在工作队列中获取任务执行, 若队列中没有任务, 则工作线程阻塞直到get到任务, 到达空闲时间便销毁. 默认情况下, 当线程数目大于核心线程池大小的时候, keepAliveTime才会起作用, 直到线程池中线程数目不大于核心线程池大小. 但是如果调用了allowCoreThreadTimeOut(boolean) 之后，线程池中的线程个数不大于核心线程池大小的时候, keepAliveTime参数也会起作用, 直到线程个数为0. RejectedExecutionHandler: 提供了四种方式来处理任务拒绝策略 1. 直接丢弃(DiscardPolicy) 2. 丢弃队列中最老的任务(DiscardOldestPolicy) 3. 抛异常(AbortPolicy) 4. 将任务分给调用线程来执行(CallerRunsPolicy). threadFactory: 用来创建新线程., 默认使用Executors.defaultThreadFactory() 来创建线程. 默认会使新创建的线程具有相同的NORM_PRIORITY优先级并且是非守护线程, 同时也设置了线程的名称. Worker和Task的区别: 虽然他们都是runnable, 但是task并没有真正执行, 只是被Worker调用了run方法, 本章后面的源码分析会提及到. 这样的过程说明: 并不是先加入任务就一定会先执行. 假设队列大小为 10, corePoolSize为3, maximumPoolSize为6, 那么当加入20个任务时, 执行的顺序就是这样的: 首先执行任务1, 2, 3, 然后任务4~13被放入队列. 这时候队列满了, 任务14, 15, 16 会被马上执行, 而任务17~20则会执行拒绝策略. 最终顺序是: 1, 2, 3, 14, 15, 16, 4, 5, 6, 7, 8, 9, 10, 11, 12 ,13. execute 方法源码分析 了解了原理之后再来看一看execute 的源码: 123456789101112131415161718192021222324252627282930313233343536373839/* * 源码里提到的关于线程池状态的知识将在下节中介绍，这里过一下就好 * 注释里1，2，3，4的序号就对应上一节流程图中的四个关键步骤 */// 这里的command就是taskpublic void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); // ctl是一个原子Integer，高3位保存线程池状态，低29位保存线程池数量 int c = ctl.get(); // 1. 用位运算方法获取Worker数量，若小于核心线程池大小，新建一个Worker // runStateOf：获取运行状态；workerCountOf：获取活动线程数；ctlOf：获取运行状态和活动线程数的值。 if (workerCountOf(c) &lt; corePoolSize) &#123; // 新建一个Worker，addWorker自动的检查当前线程池的状态和Worker的数量， // 防止线程池在不能添加线程的状态下添加线程 if (addWorker(command, true)) return; // 重新获取线程池数量 c = ctl.get(); &#125; // 核心线程池已满 // 2. 判断线程池状态，任务入队 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; // 如果任务入队成功，然后还是要进行double-check的，因为线程池在入队之后状态是可能会发生变化的 // 重新获取线程池数量 int recheck = ctl.get(); // 如果线程池状态突变，那么将reject任务，防止workQueue中增加新线程 if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) //如果在任务入队的时候Worker变为0， //那么将没有Worker执行新的task，所以增加一个Worker addWorker(null, false); &#125; // 3. 如果workQueue满了，那么这时候可能还没到maximumPoolSize，所以尝试增加一个Worker else if (!addWorker(command, false)) // 4. 如果Worker数量到达上限或者线程池状态变化了，即addWorker失败，那么就拒绝此任务 reject(command); &#125; 线程池的状态 线程池在执行各种操作的时候都会进行状态的判断，防止状态的改变导致的错误。 线程池的5种状态为： RUNNING ：能接受新提交的任务，并且也能处理阻塞队列中的任务； SHUTDOWN：关闭状态，不再接受新提交的任务，中断空闲线程，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 RUNNING 状态时，调用 shutdown()方法会使线程池进入到该状态； STOP：不能接受新任务，清空队列中的任务，而且中断运行中线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态并返回工作队列中的任务List； TIDYING：如果所有的任务都已终止了，workerCount (工作线程数) 为0，线程池进入该状态后会调用 terminated() 方法进入TERMINATED 状态。 TERMINATED：在terminated() 方法执行完后进入该状态。 进入TERMINATED的条件如下： 线程池不是RUNNING状态； 线程池状态不是TERMINATED状态； 如果线程池状态是SHUTDOWN并且workerQueue为空； 设置TIDYING状态成功。 下图为线程池的状态转换过程： addWorker 方法源码分析 execute 方法里核心方法的是addWorker 方法，看源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: for (;;) &#123; int c = ctl.get(); // 获取线程池运行状态 int rs = runStateOf(c); /** * 若rs &lt; SHUTDOWN，则进行addWorker的操作; * 若rs &gt;= SHUTDOWN，则继续判断后面三个条件，有一个不满足，则if里的条件为真，则返回false，即拒绝addWorker, * 其中，rs == SHUTDOWN时，只能加入为null的task（firstTask == null）， * 如果工作队列不为空，则可以addWork来消费队列中的task， * 如果工作队列为空，则拒绝addWork. */ if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; //获取工作线程数 int wc = workerCountOf(c); // 这里的core是addWorker方法的第二个参数，如果为true表示根据corePoolSize来比较，反之maximumPoolSize if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; // 使用比较再操作的方式尝试增加workerCount，如果成功，则跳出第一个for循环 if (compareAndIncrementWorkerCount(c)) break retry; // 如果增加workerCount失败，则重新获取ctl的值 c = ctl.get(); // 如果当前的运行状态不等于rs，说明状态已被改变，返回第一个for循环重试 if (runStateOf(c) != rs) continue retry; &#125; &#125; // Worker类继承了AQS，并实现了Runnable接口，注意其中的firstTask和thread属性：firstTask用它来保存传入的任务；thread是在调用构造方法时通过ThreadFactory来创建的线程，它才是用来处理任务的线程。 // Worker继承自AQS，是为了用于判断线程是否空闲以及是否可以被中断。（有许多信号量） Worker w = new Worker(firstTask); Thread t = w.thread; final ReentrantLock mainLock = this.mainLock; // 用一个mainlock时因为workers是HashSet类型的，不能保证线程安全 mainLock.lock(); try &#123; int c = ctl.get(); int rs = runStateOf(c); // 增加workerCount之后若线程池状态发生了变化，则减少workerCount（不进行workers.add(）） if (t == null || (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null))) &#123; decrementWorkerCount(); tryTerminate(); return false; &#125; // workers是一个HashSet workers.add(w); int s = workers.size(); // largestPoolSize记录着线程池中出现过的最大线程数量 if (s &gt; largestPoolSize) largestPoolSize = s; &#125; finally &#123; mainLock.unlock(); &#125; // 线程t启动时会调用Worker类中的run()方法，其中会调用runWorker()方法，里面调用getTask()方法来获取工作队列中的task，执行task的run()来执行任务 t.start(); // Stop或线程Interrupt的时候要中止所有的运行的Worker if (runStateOf(ctl.get()) == STOP &amp;&amp; ! t.isInterrupted()) t.interrupt(); return true;&#125; getTask 方法源码分析 上一节的最后提到的getTask()方法，Woeker究竟是如何获取任务的，看源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private Runnable getTask() &#123; // timeOut变量的值表示上次从阻塞队列中取任务时是否超时 boolean timedOut = false; for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); /* * 同addWorker，当线程池状态变化时，满足条件则将workerCount减1并返回null * 因为如果当前线程池状态的值是SHUTDOWN或以上时，不允许再向阻塞队列中添加任务。 */ if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; decrementWorkerCount(); return null; &#125; int wc = workerCountOf(c); // timed变量用于判断是否需要进行超时控制； // 这就是allowCoreThreadTimeOut的作用，若设为false，则对于超过核心线程数量的线程，需要进行超时控制 boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; /* * wc &gt; maximumPoolSize的情况是因为可能在此方法执行阶段同时执行了setMaximumPoolSize方法； * timed &amp;&amp; timedOut 如果为true，表示当前操作需要进行超时控制，并且上次从阻塞队列中获取任务发生了超时。 * 接下来判断，如果有效线程数量大于1，或者阻塞队列是空的，那么尝试将workerCount减1； * 如果减1失败，则返回重试。 * 如果wc == 1时，也就说明当前线程是线程池中唯一的一个线程了。 */ if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; try &#123; /* * 根据timed来判断，如果为true，则通过阻塞队列的poll方法进行超时控制，如果在keepAliveTime时间内没有获取到任务，则返回null； * 否则调用take方法，如果这时队列为空，则take方法会阻塞直到队列不为空。（会被shutdown方法的interruptIdleWorkers方法中断阻塞，不会造成SHUTDOWN状态下无限阻塞） */ Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; // 如果 r == null，说明已经超时，timedOut设置为true timedOut = true; &#125; catch (InterruptedException retry) &#123; // 如果获取任务时当前线程发生了中断，则设置timedOut为false并返回循环重试 timedOut = false; &#125; &#125;&#125; shutdown方法会调用interruptIdleWorkers来中断空闲线程。工作线程处理任务时会进行lock，interruptIdleWorkers在进行中断时会使用tryLock来判断该工作线程是否正在处理任务，如果tryLock返回true，说明该工作线程当前未执行任务，这时才可以被中断。shutdownNow方法则调用interruptWorkers方法中断所有线程。 getTask方法返回null时，在runWorker方法中会跳出while循环，然后会执行processWorkerExit方法，里面会判断线程池的状态变化等，来进行workerCount的增减等操作，然后工作线程等着被jvm销毁。 线程池的分类 创建线程池可以new一个ThreadPoolExecutor，这样可以自定义参数（阿里推荐的方法）；对于一般的场景，Executors 类提供了创建各种已经配好参数的线程池的方法： newCachedThreadPool() – SynchronousQueue: 创建一个可缓存线程池, 是可以无限扩大的线程池, 60s回收空闲线程, 适用于服务器负载较轻, 执行很多短期异步任务。（corePoolSize = 0，maximumPoolSize = Integer.Max，keepAliveTime = 60） newFixedThreadPool() – LinkedBlockingQueue: 创建一个定长线程, 适用于可以预测线程数量的业务中, 或者服务器负载较重, 对当前线程数量进行限制。（corePoolSize = maximumPoolSize） newScheduledThreadPool() – DelayedWorkQueue: 创建一个定长线程池，支持定时和周期性任务。(详见: 我的另一篇文章””, 链接: ) newSingleThreadExecutor() – LinkedBlockingQueue: 创建一个单线程化的线程池，适用于需要保证顺序(FIFO, LIFO)执行各个任务，并且在任意时间点，不会有多个线程是活动的场景。(corePoolSize = maximumPoolSize = 1) newWorkStealingPool() – LinkedBlockingQueue: 创建一个工作窃取线程池, 每个线程都有要自己处理的队列, 如果其中的线程完成自己队列中的任务, 那么它可以去其他队列中获取任务去执行。创建当前可用cpu数量的线程来并行执行, 适用于大耗时的操作。(相对于上面的线程池，newWorkStealingPool 用的是ForkJoinPool，有多个阻塞队列和工作线程池） 总结 以上就是整个线程池的工作流程，从execute方法开始提交任务（四种情况），worker使用ThreadFactory创建新的线程thread作为自己的属性，thread运行worker的run方法，其中调用runWorker通过getTask获取任务（空闲线程在此阻塞），然后执行任务，如果getTask返回null，进入processWorkerExit方法，woker销毁。期间线程池的状态一直可能发生变化。 不同的线程池参数设置，不同的阻塞队列的类型，不同的task封装，可以有很多不同的线程池种类，适应很多场景。在本博客的”线程池”标签里有更多详细知识可以了解。 参考掘金：深入理解 Java 线程池：ThreadPoolExecutor 简书：深入理解java线程池—ThreadPoolExecutor a1=>operation: Executor a2=>operation: ExecutorService a3=>operation: AbstractExecutorService a4=>operation: ThreadPoolExecutor a1->a2->a3->a4{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
</search>
