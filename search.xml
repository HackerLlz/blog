<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[top]]></title>
    <url>%2F2018%2F09%2F28%2Ftop%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ThreadPoolExecutor]]></title>
    <url>%2F2018%2F09%2F28%2FThreadPoolExecutor%2F</url>
    <content type="text"><![CDATA[ThreadPoolExecutor的族谱​ 在多线程的编程环境下, 为了更好的控制线程的数量和状态, 提升性能和吞吐量, 通常会用到线程池, 接下来介绍JDK里的ThreadPoolExecutor线程池. ​ 首先, ThreadPoolExecutor的继承关系为: ​ Executor接口只有一个void execute(Runnable command) 方法, ExecutorService接口添加了许多重要的方法, 源码如下: 12345678910111213141516171819202122public interface ExecutorService extends Executor &#123; // 启动一个关闭命令，不再接受新任务 // 当所有工作队列的任务执行完后，就关闭 void shutdown(); // 与shutdown() 的区别是 直接清理工作队列的任务 // 并返回未执行的任务列表 List&lt;Runnable&gt; shutdownNow(); boolean isShutdown(); boolean isTerminated(); // 提交任务, 与execute() 的区别是 会返回任务处理结果 &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result); Future&lt;?&gt; submit(Runnable task); // 批量提交任务 &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException; &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException; &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException; &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; 提交任务过程中几个参数的作用​ ThreadPoolExecutor作为实现类, 构造出了一个可以将提交的任务用特定数量的工作线程按照流程来处理的线程池, 下面看一下TPE的构造方法, 了解其中都有哪些重要的参数: 123456789101112131415161718192021public ThreadPoolExecutor(int corePoolSize, //核心线程池大小 int maximumPoolSize, //最大线程池大小 long keepAliveTime, //工作线程空闲时间 TimeUnit unit, //空闲时间的单位 BlockingQueue&lt;Runnable&gt; workQueue, //工作队列（阻塞队列） ThreadFactory threadFactory, //工作线程的创建工厂 RejectedExecutionHandler handler) &#123; //任务拒绝策略 if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; ​ 现在讲述execute 方法的执行过程来理解各个参数的作用, 先来看一张图: ​ 主线程execute 提交任务到线程池时, 线程池会先判断工作线程的数量是否小于核心线程池大小, 若是则添加一个工作线程直接执行该任务, 反之将任务加入到工作队列中. 当工作队列也满时, 线程池会继续增加工作线程来处理未能加入到工作队列中的任务, 直到工作线程的数量到达最大线程池大小, 对于继续提交的任务就会采取拒绝策略. ​ 以上的论述中, 补充以下几点: keepAliveTime: 线程多久没有任务执行就会终止的时间间隔. 当工作线程执行完一个任务之后就会用getTask 方法在工作队列中获取任务执行, 若队列中没有任务, 则工作线程阻塞直到get到任务, 到达空闲时间便销毁. 默认情况下, 当线程数目大于核心线程池大小的时候, keepAliveTime才会起作用, 直到线程池中线程数目不大于核心线程池大小. 但是如果调用了allowCoreThreadTimeOut(boolean) 之后，线程池中的线程个数不大于核心线程池大小的时候, keepAliveTime参数也会起作用, 直到线程个数为0. RejectedExecutionHandler: 提供了四种方式来处理任务拒绝策略 1. 直接丢弃(DiscardPolicy) 2. 丢弃队列中最老的任务(DiscardOldestPolicy) 3. 抛异常(AbortPolicy) 4. 将任务分给调用线程来执行(CallerRunsPolicy). threadFactory: 用来创建新线程., 默认使用Executors.defaultThreadFactory() 来创建线程. 默认会使新创建的线程具有相同的NORM_PRIORITY优先级并且是非守护线程, 同时也设置了线程的名称. Worker和Task的区别: 虽然他们都是runnable, 但是task并没有真正执行, 只是被Worker调用了run方法, 本章后面的源码分析会提及到. 这样的过程说明: 并不是先加入任务就一定会先执行. 假设队列大小为 10, corePoolSize为3, maximumPoolSize为6, 那么当加入20个任务时, 执行的顺序就是这样的: 首先执行任务1, 2, 3, 然后任务4~13被放入队列. 这时候队列满了, 任务14, 15, 16 会被马上执行, 而任务17~20则会执行拒绝策略. 最终顺序是: 1, 2, 3, 14, 15, 16, 4, 5, 6, 7, 8, 9, 10, 11, 12 ,13. execute 方法源码分析​ 了解了原理之后再来看一看execute 的源码: 123456789101112131415161718192021222324252627282930313233343536373839/* * 源码里提到的关于线程池状态的知识将在下节中介绍，这里过一下就好 * 注释里1，2，3，4的序号就对应上一节流程图中的四个关键步骤 */// 这里的command就是taskpublic void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); // ctl是一个原子Integer，高3位保存线程池状态，低29位保存线程池数量 int c = ctl.get(); // 1. 用位运算方法获取Worker数量，若小于核心线程池大小，新建一个Worker // runStateOf：获取运行状态；workerCountOf：获取活动线程数；ctlOf：获取运行状态和活动线程数的值。 if (workerCountOf(c) &lt; corePoolSize) &#123; // 新建一个Worker，addWorker自动的检查当前线程池的状态和Worker的数量， // 防止线程池在不能添加线程的状态下添加线程 if (addWorker(command, true)) return; // 重新获取线程池数量 c = ctl.get(); &#125; // 核心线程池已满 // 2. 判断线程池状态，任务入队 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; // 如果任务入队成功，然后还是要进行double-check的，因为线程池在入队之后状态是可能会发生变化的 // 重新获取线程池数量 int recheck = ctl.get(); // 如果线程池状态突变，那么将reject任务，防止workQueue中增加新线程 if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) //如果在任务入队的时候Worker变为0， //那么将没有Worker执行新的task，所以增加一个Worker addWorker(null, false); &#125; // 3. 如果workQueue满了，那么这时候可能还没到maximumPoolSize，所以尝试增加一个Worker else if (!addWorker(command, false)) // 4. 如果Worker数量到达上限或者线程池状态变化了，即addWorker失败，那么就拒绝此任务 reject(command); &#125; 线程池的状态​ 线程池在执行各种操作的时候都会进行状态的判断，防止状态的改变导致的错误。 ​ 线程池的5种状态为： RUNNING ：能接受新提交的任务，并且也能处理阻塞队列中的任务； SHUTDOWN：关闭状态，不再接受新提交的任务，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 RUNNING 状态时，调用 shutdown()方法会使线程池进入到该状态； STOP：不能接受新任务，也不处理队列中的任务，而且尝试中断运行中任务。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态； TIDYING：如果所有的任务都已终止了，workerCount (工作线程数) 为0，线程池进入该状态后会调用 terminated() 方法进入TERMINATED 状态。 TERMINATED：在terminated() 方法执行完后进入该状态。 进入TERMINATED的条件如下： 线程池不是RUNNING状态； 线程池状态不是TERMINATED状态； 如果线程池状态是SHUTDOWN并且workerQueue为空； 设置TIDYING状态成功。 ​ 下图为线程池的状态转换过程： addWorker 方法源码分析​ execute 方法里核心方法的是addWorker 方法，看源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: for (;;) &#123; int c = ctl.get(); // 获取运行状态 int rs = runStateOf(c); /** * 如果当前的线程池的状态&gt;SHUTDOWN，那么拒绝Worker的add，如果=SHUTDOWN， * 那么此时不能新加入不为null的Task，如果在WorkCount为empty的时候不能加入任何类型的Worker， * 如果不为empty可以加入task为null的Worker,增加消费的Worker */ if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; int wc = workerCountOf(c); if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; if (compareAndIncrementWorkerCount(c)) break retry; c = ctl.get(); if (runStateOf(c) != rs) continue retry; &#125; &#125; Worker w = new Worker(firstTask); Thread t = w.thread; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; int c = ctl.get(); int rs = runStateOf(c); // 同样检测当rs&gt;SHUTDOWN时直接拒绝减小Wc，同时Terminate，如果为SHUTDOWN同时firstTask不为null的时候也要Terminate if (t == null || (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null))) &#123; decrementWorkerCount(); tryTerminate(); return false; &#125; workers.add(w); int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; &#125; finally &#123; mainLock.unlock(); &#125; t.start(); //Stop或线程Interrupt的时候要中止所有的运行的Worker if (runStateOf(ctl.get()) == STOP &amp;&amp; ! t.isInterrupted()) t.interrupt(); return true;&#125; getTask 方法源码分析​ 12 线程池的分类​ 创建线程池可以new一个ThreadPoolExecutor，这样可以自定义参数（阿里推荐的方法）；对于一般的场景，Executors 类提供了创建各种已经配好参数的线程池的方法： newCachedThreadPool() – SynchronousQueue: 创建一个可缓存线程池, 是可以无限扩大的线程池, 60s回收空闲线程, 适用于服务器负载较轻, 执行很多短期异步任务。（corePoolSize = 0，maximumPoolSize = Integer.Max，keepAliveTime = 60） newFixedThreadPool() – LinkedBlockingQueue: 创建一个定长线程, 适用于可以预测线程数量的业务中, 或者服务器负载较重, 对当前线程数量进行限制。（corePoolSize = maximumPoolSize） newScheduledThreadPool() – DelayedWorkQueue: 创建一个定长线程池，支持定时和周期性任务。(详见: 我的另一篇文章””, 链接: ) newSingleThreadExecutor() – LinkedBlockingQueue: 创建一个单线程化的线程池，适用于需要保证顺序(FIFO, LIFO)执行各个任务，并且在任意时间点，不会有多个线程是活动的场景。(corePoolSize = maximumPoolSize = 1) newWorkStealingPool() – LinkedBlockingQueue: 创建一个工作窃取线程池, 每个线程都有要自己处理的队列, 如果其中的线程完成自己队列中的任务, 那么它可以去其他队列中获取任务去执行。创建当前可用cpu数量的线程来并行执行, 适用于大耗时的操作。(相对于上面的线程池，newWorkStealingPool 用的是ForkJoinPool，有多个阻塞队列和工作线程池） a1=>operation: Executor a2=>operation: ExecutorService a3=>operation: AbstractExecutorService a4=>operation: ThreadPoolExecutor a1->a2->a3->a4{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[world]]></title>
    <url>%2F2018%2F09%2F28%2Fworld%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[hello]]></title>
    <url>%2F2018%2F09%2F28%2Fhello%2F</url>
    <content type="text"></content>
  </entry>
</search>
