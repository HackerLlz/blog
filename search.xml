<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[top]]></title>
    <url>%2F2018%2F09%2F28%2Ftop%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[ThreadPoolExecutor]]></title>
    <url>%2F2018%2F09%2F28%2FThreadPoolExecutor%2F</url>
    <content type="text"><![CDATA[ThreadPoolExecutor的族谱​ 在多线程的编程环境下, 为了更好的控制线程的数量和状态, 提升性能和吞吐量, 通常会用到线程池, 接下来介绍JDK里的ThreadPoolExecutor线程池. ​ 首先, ThreadPoolExecutor的继承关系为: ​ Executor接口只有一个void execute(Runnable command) 方法, ExecutorService接口添加了许多重要的方法, 源码如下: 12345678910111213141516171819202122public interface ExecutorService extends Executor &#123; // 启动一个关闭命令，不再接受新任务 // 当所有工作队列的任务执行完后，就关闭 void shutdown(); // 与shutdown() 的区别是 直接清理工作队列的任务 // 并返回未执行的任务列表 List&lt;Runnable&gt; shutdownNow(); boolean isShutdown(); boolean isTerminated(); // 提交任务, 与execute() 的区别是 会返回任务处理结果 &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result); Future&lt;?&gt; submit(Runnable task); // 批量提交任务 &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException; &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException; &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException; &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; 提交任务过程中几个参数的作用​ ThreadPoolExecutor作为实现类, 构造出了一个可以将提交的任务用特定数量的工作线程按照流程来处理的线程池, 下面看一下TPE的构造方法, 了解其中都有哪些重要的参数: 123456789101112131415161718192021public ThreadPoolExecutor(int corePoolSize, //核心线程池大小 int maximumPoolSize, //最大线程池大小 long keepAliveTime, //工作线程空闲时间 TimeUnit unit, //空闲时间的单位 BlockingQueue&lt;Runnable&gt; workQueue, //工作队列（阻塞队列） ThreadFactory threadFactory, //工作线程的创建工厂 RejectedExecutionHandler handler) &#123; //任务拒绝策略 if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler;&#125; ​ 现在讲述execute 方法的执行过程来理解各个参数的作用, 先来看一张图: ​ 主线程execute 提交任务到线程池时, 线程池会先判断工作线程的数量是否小于核心线程池大小, 若是则添加一个工作线程直接执行该任务, 反之将任务加入到工作队列中. 当工作队列也满时, 线程池会继续增加工作线程来处理未能加入到工作队列中的任务, 直到工作线程的数量到达最大线程池大小, 对于继续提交的任务就会采取拒绝策略. ​ 以上的论述中, 补充以下几点: keepAliveTime: 线程多久没有任务执行就会终止的时间间隔. 当工作线程执行完一个任务之后就会用getTask 方法在工作队列中获取任务执行, 若队列中没有任务, 则工作线程阻塞直到get到任务, 到达空闲时间便销毁. 默认情况下, 当线程数目大于核心线程池大小的时候, keepAliveTime才会起作用, 直到线程池中线程数目不大于核心线程池大小. 但是如果调用了allowCoreThreadTimeOut(boolean) 之后，线程池中的线程个数不大于核心线程池大小的时候, keepAliveTime参数也会起作用, 直到线程个数为0. RejectedExecutionHandler: 提供了四种方式来处理任务拒绝策略 1. 直接丢弃(DiscardPolicy) 2. 丢弃队列中最老的任务(DiscardOldestPolicy) 3. 抛异常(AbortPolicy) 4. 将任务分给调用线程来执行(CallerRunsPolicy). threadFactory: 用来创建新线程., 默认使用Executors.defaultThreadFactory() 来创建线程. 默认会使新创建的线程具有相同的NORM_PRIORITY优先级并且是非守护线程, 同时也设置了线程的名称. Worker和Task的区别: 虽然他们都是runnable, 但是task并没有真正执行, 只是被Worker调用了run方法, 本章后面的源码分析会提及到. 这样的过程说明: 并不是先加入任务就一定会先执行. 假设队列大小为 10, corePoolSize为3, maximumPoolSize为6, 那么当加入20个任务时, 执行的顺序就是这样的: 首先执行任务1, 2, 3, 然后任务4~13被放入队列. 这时候队列满了, 任务14, 15, 16 会被马上执行, 而任务17~20则会执行拒绝策略. 最终顺序是: 1, 2, 3, 14, 15, 16, 4, 5, 6, 7, 8, 9, 10, 11, 12 ,13. execute 方法源码分析​ 了解了原理之后再来看一看execute 的源码: 123456789101112131415161718192021222324252627282930313233343536373839/* * 源码里提到的关于线程池状态的知识将在下节中介绍，这里过一下就好 * 注释里1，2，3，4的序号就对应上一节流程图中的四个关键步骤 */// 这里的command就是taskpublic void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); // ctl是一个原子Integer，高3位保存线程池状态，低29位保存线程池数量 int c = ctl.get(); // 1. 用位运算方法获取Worker数量，若小于核心线程池大小，新建一个Worker // runStateOf：获取运行状态；workerCountOf：获取活动线程数；ctlOf：获取运行状态和活动线程数的值。 if (workerCountOf(c) &lt; corePoolSize) &#123; // 新建一个Worker，addWorker自动的检查当前线程池的状态和Worker的数量， // 防止线程池在不能添加线程的状态下添加线程 if (addWorker(command, true)) return; // 重新获取线程池数量 c = ctl.get(); &#125; // 核心线程池已满 // 2. 判断线程池状态，任务入队 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; // 如果任务入队成功，然后还是要进行double-check的，因为线程池在入队之后状态是可能会发生变化的 // 重新获取线程池数量 int recheck = ctl.get(); // 如果线程池状态突变，那么将reject任务，防止workQueue中增加新线程 if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); else if (workerCountOf(recheck) == 0) //如果在任务入队的时候Worker变为0， //那么将没有Worker执行新的task，所以增加一个Worker addWorker(null, false); &#125; // 3. 如果workQueue满了，那么这时候可能还没到maximumPoolSize，所以尝试增加一个Worker else if (!addWorker(command, false)) // 4. 如果Worker数量到达上限或者线程池状态变化了，即addWorker失败，那么就拒绝此任务 reject(command); &#125; 线程池的状态​ 线程池在执行各种操作的时候都会进行状态的判断，防止状态的改变导致的错误。 ​ 线程池的5种状态为： RUNNING ：能接受新提交的任务，并且也能处理阻塞队列中的任务； SHUTDOWN：关闭状态，不再接受新提交的任务，中断空闲线程，但却可以继续处理阻塞队列中已保存的任务。在线程池处于 RUNNING 状态时，调用 shutdown()方法会使线程池进入到该状态； STOP：不能接受新任务，清空队列中的任务，而且中断运行中线程。在线程池处于 RUNNING 或 SHUTDOWN 状态时，调用 shutdownNow() 方法会使线程池进入到该状态并返回工作队列中的任务List； TIDYING：如果所有的任务都已终止了，workerCount (工作线程数) 为0，线程池进入该状态后会调用 terminated() 方法进入TERMINATED 状态。 TERMINATED：在terminated() 方法执行完后进入该状态。 进入TERMINATED的条件如下： 线程池不是RUNNING状态； 线程池状态不是TERMINATED状态； 如果线程池状态是SHUTDOWN并且workerQueue为空； 设置TIDYING状态成功。 ​ 下图为线程池的状态转换过程： ​ addWorker 方法源码分析​ execute 方法里核心方法的是addWorker 方法，看源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: for (;;) &#123; int c = ctl.get(); // 获取线程池运行状态 int rs = runStateOf(c); /** * 若rs &lt; SHUTDOWN，则进行addWorker的操作; * 若rs &gt;= SHUTDOWN，则继续判断后面三个条件，有一个不满足，则if里的条件为真，则返回false，即拒绝addWorker, * 其中，rs == SHUTDOWN时，只能加入为null的task（firstTask == null）， * 如果工作队列不为空，则可以addWork来消费队列中的task， * 如果工作队列为空，则拒绝addWork. */ if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; //获取工作线程数 int wc = workerCountOf(c); // 这里的core是addWorker方法的第二个参数，如果为true表示根据corePoolSize来比较，反之maximumPoolSize if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; // 使用比较再操作的方式尝试增加workerCount，如果成功，则跳出第一个for循环 if (compareAndIncrementWorkerCount(c)) break retry; // 如果增加workerCount失败，则重新获取ctl的值 c = ctl.get(); // 如果当前的运行状态不等于rs，说明状态已被改变，返回第一个for循环重试 if (runStateOf(c) != rs) continue retry; &#125; &#125; // Worker类继承了AQS，并实现了Runnable接口，注意其中的firstTask和thread属性：firstTask用它来保存传入的任务；thread是在调用构造方法时通过ThreadFactory来创建的线程，它才是用来处理任务的线程。 // Worker继承自AQS，是为了用于判断线程是否空闲以及是否可以被中断。（有许多信号量） Worker w = new Worker(firstTask); Thread t = w.thread; final ReentrantLock mainLock = this.mainLock; // 用一个mainlock时因为workers是HashSet类型的，不能保证线程安全 mainLock.lock(); try &#123; int c = ctl.get(); int rs = runStateOf(c); // 增加workerCount之后若线程池状态发生了变化，则减少workerCount（不进行workers.add(）） if (t == null || (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null))) &#123; decrementWorkerCount(); tryTerminate(); return false; &#125; // workers是一个HashSet workers.add(w); int s = workers.size(); // largestPoolSize记录着线程池中出现过的最大线程数量 if (s &gt; largestPoolSize) largestPoolSize = s; &#125; finally &#123; mainLock.unlock(); &#125; // 线程t启动时会调用Worker类中的run()方法，其中会调用runWorker()方法，里面调用getTask()方法来获取工作队列中的task，执行task的run()来执行任务 t.start(); // Stop或线程Interrupt的时候要中止所有的运行的Worker if (runStateOf(ctl.get()) == STOP &amp;&amp; ! t.isInterrupted()) t.interrupt(); return true;&#125; getTask 方法源码分析​ 上一节的最后提到的getTask()方法，Woeker究竟是如何获取任务的，看源码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private Runnable getTask() &#123; // timeOut变量的值表示上次从阻塞队列中取任务时是否超时 boolean timedOut = false; for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); /* * 同addWorker，当线程池状态变化时，满足条件则将workerCount减1并返回null * 因为如果当前线程池状态的值是SHUTDOWN或以上时，不允许再向阻塞队列中添加任务。 */ if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; decrementWorkerCount(); return null; &#125; int wc = workerCountOf(c); // timed变量用于判断是否需要进行超时控制； // 这就是allowCoreThreadTimeOut的作用，若设为false，则对于超过核心线程数量的线程，需要进行超时控制 boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; /* * wc &gt; maximumPoolSize的情况是因为可能在此方法执行阶段同时执行了setMaximumPoolSize方法； * timed &amp;&amp; timedOut 如果为true，表示当前操作需要进行超时控制，并且上次从阻塞队列中获取任务发生了超时。 * 接下来判断，如果有效线程数量大于1，或者阻塞队列是空的，那么尝试将workerCount减1； * 如果减1失败，则返回重试。 * 如果wc == 1时，也就说明当前线程是线程池中唯一的一个线程了。 */ if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; try &#123; /* * 根据timed来判断，如果为true，则通过阻塞队列的poll方法进行超时控制，如果在keepAliveTime时间内没有获取到任务，则返回null； * 否则调用take方法，如果这时队列为空，则take方法会阻塞直到队列不为空。（会被shutdown方法的interruptIdleWorkers方法中断阻塞，不会造成SHUTDOWN状态下无限阻塞） */ Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; // 如果 r == null，说明已经超时，timedOut设置为true timedOut = true; &#125; catch (InterruptedException retry) &#123; // 如果获取任务时当前线程发生了中断，则设置timedOut为false并返回循环重试 timedOut = false; &#125; &#125;&#125; ​ shutdown方法会调用interruptIdleWorkers来中断空闲线程。工作线程处理任务时会进行lock，interruptIdleWorkers在进行中断时会使用tryLock来判断该工作线程是否正在处理任务，如果tryLock返回true，说明该工作线程当前未执行任务，这时才可以被中断。shutdownNow方法则调用interruptWorkers方法中断所有线程。 ​ getTask方法返回null时，在runWorker方法中会跳出while循环，然后会执行processWorkerExit方法，里面会判断线程池的状态变化等，来进行workerCount的增减等操作，然后工作线程等着被jvm销毁。 ​ 总结：以上就是整个线程池的工作流程，从execute方法开始提交任务（四种情况），worker使用ThreadFactory创建新的线程thread作为自己的属性，thread运行worker的run方法，其中调用runWorker通过getTask获取任务（空闲线程在此阻塞），然后执行任务，如果getTask返回null，进入processWorkerExit方法，woker销毁。期间线程池的状态一直可能发生变化。 线程池的分类​ 创建线程池可以new一个ThreadPoolExecutor，这样可以自定义参数（阿里推荐的方法）；对于一般的场景，Executors 类提供了创建各种已经配好参数的线程池的方法： newCachedThreadPool() – SynchronousQueue: 创建一个可缓存线程池, 是可以无限扩大的线程池, 60s回收空闲线程, 适用于服务器负载较轻, 执行很多短期异步任务。（corePoolSize = 0，maximumPoolSize = Integer.Max，keepAliveTime = 60） newFixedThreadPool() – LinkedBlockingQueue: 创建一个定长线程, 适用于可以预测线程数量的业务中, 或者服务器负载较重, 对当前线程数量进行限制。（corePoolSize = maximumPoolSize） newScheduledThreadPool() – DelayedWorkQueue: 创建一个定长线程池，支持定时和周期性任务。(详见: 我的另一篇文章””, 链接: ) newSingleThreadExecutor() – LinkedBlockingQueue: 创建一个单线程化的线程池，适用于需要保证顺序(FIFO, LIFO)执行各个任务，并且在任意时间点，不会有多个线程是活动的场景。(corePoolSize = maximumPoolSize = 1) newWorkStealingPool() – LinkedBlockingQueue: 创建一个工作窃取线程池, 每个线程都有要自己处理的队列, 如果其中的线程完成自己队列中的任务, 那么它可以去其他队列中获取任务去执行。创建当前可用cpu数量的线程来并行执行, 适用于大耗时的操作。(相对于上面的线程池，newWorkStealingPool 用的是ForkJoinPool，有多个阻塞队列和工作线程池） 参考链接掘金：深入理解 Java 线程池：ThreadPoolExecutor：https://juejin.im/entry/58fada5d570c350058d3aaad 简书：深入理解java线程池—ThreadPoolExecutor：https://www.jianshu.com/p/ade771d2c9c0 a1=>operation: Executor a2=>operation: ExecutorService a3=>operation: AbstractExecutorService a4=>operation: ThreadPoolExecutor a1->a2->a3->a4{"scale":1,"line-width":2,"line-length":50,"text-margin":10,"font-size":12} var code = document.getElementById("flowchart-0-code").value; var options = JSON.parse(decodeURIComponent(document.getElementById("flowchart-0-options").value)); var diagram = flowchart.parse(code); diagram.drawSVG("flowchart-0", options);]]></content>
      <tags>
        <tag>线程池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[world]]></title>
    <url>%2F2018%2F09%2F28%2Fworld%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[hello]]></title>
    <url>%2F2018%2F09%2F28%2Fhello%2F</url>
    <content type="text"></content>
  </entry>
</search>
